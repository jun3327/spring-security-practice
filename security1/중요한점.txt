*스프링 시큐리티의 동작 방식
- 서버의 세션 저장소 안에, 스프링 시큐리티가 관리하는 세션이 따로 있다.
- 시큐리티 세션 안에 저장될 수 있는 객체는 Authentication 객체 뿐이다. 이 객체가 세션에 들어온 순간 로그인이 된거다.
- 이 Authentication 객체를 컨트롤러에서 필요할 때 DI 할 수 있다.
- Authentication 안에는 두 개의 타입이 있다. (UserDetails, OAuth2User)
- 일반 로그인을 진행하면 UserDetails 타입으로, OAuth2 로그인을 진행하면 OAuth2User로 들어온다.

*PrincipalDetails 클래스의 구성
- 근데, 컨트롤러에서 OAuth2User 인지, UserDetails 인지에 따라 구분하여 처리하기가 매우 빡세다
- 그래서, Authenticaion 안에 들어가는 객체를 하나 만들어서(PrincipalDetails), 그 객체가 UserDetails와 OAuth2User를
모두 상속해서 구현하도록 만든다.
- 그렇게 하면 컨트롤러에서 둘을 구분해서 받을 필요가 없다. 오직 PrincipalDetails에 관하여 처리하면 된다.

*oauth2-client의 Provider
-oauth2 cleint를 제공해주는 제공자인 Provider 중 스프링에서 구글, 페북, 트위터는 기본 제공자로 제공을 해준다(네이버 카톡은 없음)
-따라서 카톡이나 네이버는 Provider로 등록을 해줘야됨.

*React 연동 REST API 방식
-https://cafe.naver.com/metacoding/1176

*Naver가 리턴 하는 json 형식
response =
{   resultcode=00,
    message=success,
    response={id=CD9_JmNRSDxxxxx_xxxxxxxxxxx, email=xxx@xxx.com, name=김댕댕}
}

*JWT가 사용되는 이유, 어디에 어떻게 쓰이는지
- 세션이 쓰이는 이유
  1. 세션ID를 통한 인증, 인가 --> 클라이언트 식별
- 세션 방식의 단점
  1. 세션ID를 저장할 저장소의 물리적인 한계
  2. 로드 밸런싱 시 서버의 특성은 stateless 한데 세션의 특성은 stateful
- 해결책
  1. 공유 저장소(하드디스크, redis 등 메모리 기반 공유저장소))
  2. 세션 복제(서버 간 세션 데이터 동기화)
  3. jwt

*RSA 암호화
public key: 공개키(공개해도 상관없음)
private key: 개인키(개인만 알아야됨)
1. 공개키로 데이터 암호화
- A가 B에게 C라는 데이터를 전송할 때, A가 C를 B의 공개키로 암호화하고, 이 데이터는 B의 개인키로만 decode가 가능함
- 따라서 중간에 D라는 사람이 C를 낚아채도, decode가 불가함.
- 암호화에 사용
2. 개인키로 데이터 암호화
- A가 B에게 C라는 데이터를 전송할 때, A가 C를 자신의 개인키로 암호화. 이 과정에서 데이터는 제3자인 D가 낚아채서
- A의 공개키로 열람할 수도 있고, B가 데이터를 받아 A의 공개키로 decode 할 수도 있다.
- 데이터를 받는 사람은 해당 데이터가 A의 공개키로만 열린다는 것을 알면, A의 개인키로 암호화되어있다는 의미이기 때문에
A에게서 온 데이터임을 확신할 수 있다.
- 전자서명에서 인증에 사용

3. 1과 2의 조합
- 1번 공개키 방식에서, 제 3자가 데이터를 탈취하여 임의의 데이터를 생성하고 악용할 수 있기 떄문에, 2번과 조합해서
B의 공개키로 암호화된 데이터를 A의 개인키로 다시 한 번 암호화한다. 이는 일종의 프로토콜로, 이렇게 하면 데이터의 신원을
A라고 보장할 수 있으며 중간에 탈취해도 A의 비밀키는 제 3자가 알 수 없기 때문에 임의의 데이터는 무시할 수 있다.
데이터를 받은 B는 A의 공개키로 한 번 복호화하고, 자신의 개인키를 이용하여 다시 한 번 복호화 하여 데이터에 접근한다.
--> 키 전달의 문제와, 인증의 문제 모두 해결.

*JWT의 구조와 암호화 방식
- JWT는 Header, Payload, Signature로 구성되어 있다.
- Header에는 토큰의 타입, 토큰의 암호화 방식이 적혀있음(HS256, RSA) --> Base64Url 인코딩
HS256은 HMAC방식과 SHA256방식을 조합한 암호화 방식으로, HMAC은 시크릿키를 포함한 것이고 SHA256은 해쉬성을 가짐
- Payload에는 Claim 들이 들어있음. 예를 들어 유저 정보, 권한 등 --> Base64Url 인코딩
이 Header와 Payload는 제 3자가 디코딩 할 수 있기 때문에, 민감한 정보를 담으면 안된다. --> JWT의 초점은 인증에 맞춰져있음.
- Signature는 Base64로 인코딩된 Header와 Payload를 조합한다. 여기에 서버만 알고있는 시크릿키를 포함시킨다.
Header, Payload, 시크릿키를 포함한 Signature를 HS256 방식으로 암호화--> 해쉬성이라 복호화 불가
클라이언트가 서버로부터 전달 받은 인코딩된 JWT 토큰을 인증을 위해 다시 서버에 전달하면, 서버는 복호화 한 Header, Payload + 서버 자신의 시크릿키를 조합해 HS256으로 암호화해서
그 값이 클라이언트로부터 전달 받은토큰의 난수 값과 같으면 인증 완료.

만약 RSA 방식으로 토큰을 암호화 할 경우, 서버의 개인키로 토큰을 암호화해서 클라이언트에게 돌려준다. 그러면 HS256 방식에서의 시크릿키가 필요없음.
RSA보다 HS256을 더 많이 사용한다

- JWT토큰 사용 시 세션과 대비한 장점은, HS256 방식일 경우 서버들은 데이터를 동기화 할 필요 없이, 시크릿키만
공유하여 유효한 토큰인지 검증만 해주면 된다.




