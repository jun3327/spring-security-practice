*스프링 시큐리티의 동작 방식
- 서버의 세션 저장소 안에, 스프링 시큐리티가 관리하는 세션이 따로 있다.
- 시큐리티 세션 안에 저장될 수 있는 객체는 Authentication 객체 뿐이다. 이 객체가 세션에 들어온 순간 로그인이 된거다.
- 이 Authentication 객체를 컨트롤러에서 필요할 때 DI 할 수 있다.
- Authentication 안에는 두 개의 타입이 있다. (UserDetails, OAuth2User)
- 일반 로그인을 진행하면 UserDetails 타입으로, OAuth2 로그인을 진행하면 OAuth2User로 들어온다.

*PrincipalDetails 클래스의 구성
- 근데, 컨트롤러에서 OAuth2User 인지, UserDetails 인지에 따라 구분하여 처리하기가 매우 빡세다
- 그래서, Authenticaion 안에 들어가는 객체를 하나 만들어서(PrincipalDetails), 그 객체가 UserDetails와 OAuth2User를
모두 상속해서 구현하도록 만든다.
- 그렇게 하면 컨트롤러에서 둘을 구분해서 받을 필요가 없다. 오직 PrincipalDetails에 관하여 처리하면 된다.

*oauth2-client의 Provider
-oauth2 cleint를 제공해주는 제공자인 Provider 중 스프링에서 구글, 페북, 트위터는 기본 제공자로 제공을 해준다(네이버 카톡은 없음)
-따라서 카톡이나 네이버는 Provider로 등록을 해줘야됨.

*React 연동 REST API 방식
-https://cafe.naver.com/metacoding/1176

*Naver가 리턴 하는 json 형식
response =
{   resultcode=00,
    message=success,
    response={id=CD9_JmNRSDxxxxx_xxxxxxxxxxx, email=xxx@xxx.com, name=김댕댕}
}

*JWT가 사용되는 이유, 어디에 어떻게 쓰이는지
- 세션이 쓰이는 이유
  1. 세션ID를 통한 인증, 인가 --> 클라이언트 식별
- 세션 방식의 단점
  1. 세션ID를 저장할 저장소의 물리적인 한계
  2. 로드 밸런싱 시 서버의 특성은 stateless 한데 세션의 특성은 stateful
- 해결책
  1. 공유 저장소(하드디스크, redis 등 메모리 기반 공유저장소))
  2. 세션 복제(서버 간 세션 데이터 동기화)
  3. jwt





